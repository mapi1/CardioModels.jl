"""
    BaselliModel()

A simple structure that stores a Baselli-model in form of transfer functions. It has a recipe defined to get some bode plots. 

The default initialization is not proper, to get a working model use 'getModel(sim)', which gives one of the four configurations from the original paper.

# Examples
```julia
julia> model = getModel(1)
[ Info: Simulation 1: Respiration enters on S (LF are generated in the S, S loop)
BaselliModel
  G_SI: ControlSystems.TransferFunction{ControlSystems.Discrete{Int64}, ControlSystems.SisoRational{Float64}}
  G_IS: ControlSystems.TransferFunction{ControlSystems.Discrete{Int64}, ControlSystems.SisoRational{Float64}}
  G_SS: ControlSystems.TransferFunction{ControlSystems.Discrete{Int64}, ControlSystems.SisoRational{Float64}}
  MS: ControlSystems.TransferFunction{ControlSystems.Discrete{Int64}, ControlSystems.SisoRational{Float64}}
  MI: ControlSystems.TransferFunction{ControlSystems.Discrete{Int64}, ControlSystems.SisoRational{Float64}}
  Mρ: ControlSystems.TransferFunction{ControlSystems.Discrete{Int64}, ControlSystems.SisoRational{Float64}}
  R_Sρ: ControlSystems.TransferFunction{ControlSystems.Discrete{Int64}, ControlSystems.SisoRational{Float64}}
  R_Iρ: ControlSystems.TransferFunction{ControlSystems.Discrete{Int64}, ControlSystems.SisoRational{Float64}}
  Gs: ControlSystems.TransferFunction{ControlSystems.Discrete{Int64}, ControlSystems.SisoRational{Int64}}
  Gt: ControlSystems.TransferFunction{ControlSystems.Discrete{Int64}, ControlSystems.SisoRational{Int64}}
  DS: ControlSystems.TransferFunction{ControlSystems.Discrete{Int64}, ControlSystems.SisoRational{Int64}}
  DI: ControlSystems.TransferFunction{ControlSystems.Discrete{Int64}, ControlSystems.SisoRational{Int64}}
  wS: Distributions.Normal{Float64}
  wI: Distributions.Normal{Float64}
  wρ: Distributions.Normal{Float64}
  n: Int64 10
  N: Int64 0
  pS_anderson: Int64 -1
  pI_anderson: Int64 -1
  res_S: Array{Float64}((0,)) Float64[]
  res_I: Array{Float64}((0,)) Float64[]
```
"""
@with_kw mutable struct BaselliModel
    # Transfer Functions
    G_SI::TransferFunction = tf([0], 1)
    G_IS::TransferFunction = tf([0], 1)
    G_SS::TransferFunction = tf([0], 1)
    MS::TransferFunction = tf([0], 1)
    MI::TransferFunction = tf([0], 1)
    Mρ::TransferFunction = tf([0], 1)
    R_Sρ::TransferFunction = tf([0], 1)
    R_Iρ::TransferFunction = tf([0], 1)
    Gs::TransferFunction = tf([0], 1)
    Gt::TransferFunction = tf([0], 1)
    DS::TransferFunction = tf([0], 1)
    DI::TransferFunction = tf([0], 1)
    # Input GWN
    wS::Distribution = Normal(0,1)
    wI::Distribution = Normal(0,1)
    wρ::Distribution = Normal(0,1)

    # Data associsated with fitting, to calculate quality measures later on
    # Order
    n::Integer = 10
    # Data length (beats)
    N::Integer = 0
    # Witheness of residuals according to 5% Anderson TransferFunction 
    pS_anderson::Real = -1
    pI_anderson::Real = -1
    # residuals for further tests
    res_S::Vector{<:Real} = Float64[]
    res_I::Vector{<:Real} = Float64[]
end

"""
    predict(model::BaselliModel, N::Int; burnIn::Int = 50) 

Predicts 'N' values of the cardiovascular variables for the respective model. With 'burnIn' a certain number af values can be dropped in the beginning.
    
# Examples
```julia
 julia> S, I, ρ = predict(model, 100)  
 (S = [...], I = [...], ρ = [...])   
 ```
 """
function predict(model::BaselliModel, N::Int; burnIn::Int = 50)
    Random.seed!(1234)
    # Generate white noise input
    wρ = rand(model.wρ, N+burnIn)
    wS = rand(model.wS, N+burnIn)
    wI = rand(model.wI, N+burnIn)
    # time base for simulation
    T = 1:N+burnIn
    # respiration
    ρ = lsim(model.Mρ, wρ, T)[1][:]
    # w = [wS wI ρ]
    
    # a priori known 
    rs = lsim(model.R_Sρ, ρ, T)[1][:]
    us = lsim(model.MS, wS, T)[1][:]
    cs = rs .+ us
    
    rt = lsim(model.R_Iρ, ρ, T)[1][:]
    ut = lsim(model.MI, wI, T)[1][:]
    ct = rt .+ ut
    
    # feedback dependend generate S and I 
    Gs_cs = 1 / (1 - model.G_SS - (model.G_SI * model.G_IS))
    Gs_ct = model.G_SI / (1 - model.G_SS - (model.G_SI * model.G_IS))
    S = lsim([Gs_cs Gs_ct], [cs ct], T)[1][:]
    
    Gt_cs = model.G_IS / (1 - model.G_SS - (model.G_SI * model.G_IS))
    Gt_ct = 1 / (1 - ((model.G_IS * model.G_SI) / (1 - model.G_SS)))
    I = lsim([Gt_cs Gt_ct], [cs ct], T)[1][:]
    
    # return S, I and ρ
    return (S = S[burnIn+1:end], I = I[burnIn+1:end], ρ = ρ[burnIn+1:end])
end

# Simulations from original paper Baselli et al. 1988
"""
    getModel(sim::Int)

Gives a proper Baselli-model taken from the original paper, where 'sim' can take the value from 1:4, with the meaning:

* 1: Respiration enters on S (LF are generated in the S, S loop)
* 2: Respiration enters on I (LF are generated in the S, S loop)
* 3: The LF are generated by S regulating feedback in the S, S loop (respiration enters both on S and on I)
* 4: LF are generated externally from the closed-loop system (i.e., via a central command-respiration enters both on S and on I)

"""
function getModel(sim::Int)
    # Same for all simulations
    gSI = [0,-15]
    G_SI = impRes2tf(gSI)
    gIS = [range(0.005, stop = 0, length = 6);]
    G_IS = impRes2tf(gIS)
    gSS = [0, 0.5, 0, 0, -0.05, -0.1, -0.2, -0.1, -0.05]
    
    MS = tf([1], [1, 0, -0.25], 1)
    wS = Normal(0, sqrt(5))
    
    MI = tf([1], [1, -0.7], 1)
    wI = Normal(0, sqrt(0.00005))
    # AR(2) process
    wρ = Normal(0,1)
    # Mρ = zpk(Int[], [pol2imag(0.9, 0.44pi), pol2imag(0.9, -0.44pi)], 1, 1)
    Mρ = tf([1], [1, -0.337, 0.81], 1)
    
    gainFactor_S = 1/6
    gainFactor_I = 1/6
    
    # Unique properties
    if sim == 1
        @info "Simulation 1: Respiration enters on S (LF are generated in the S, S loop)"
        gainFactor_I = 0.1/6
    elseif sim == 2 
        @info "Simulation 2: Respiration enters on I (LF are generated in the S, S loop)"
        gainFactor_S = 0.1/6
    elseif sim == 3
        @info "Simulation 3: The LF are generated by S regulating feedback in the S, S loop (respiration enters both on S and on I)"
    elseif sim == 4
        @info "Simulation 4: LF are generated externally from the closed-loop system (i.e., via a central command-respiration enters both on S and on I)"
        gSS = [0, 0.5] 
        MS = zpk( Int[], [pol2imag(0.95, 0.14π), pol2imag(0.95, -0.14π)], 1, 1)
    else
        throw(DomainError(sim, "Only simulation 1:4 exist. Choose one of them."))
    end
    impulse_S = gainFactor_S .* [3:-1:1;]
    R_Sρ = impRes2tf([0; impulse_S])
    impulse_I = gainFactor_I .* [3:-1:1;]
    R_Iρ = impRes2tf([0; impulse_I])
    G_SS = impRes2tf(gSS)
    
    return BaselliModel(G_SI = G_SI, G_IS = G_IS, G_SS = G_SS, MS = MS, wS = wS, MI = MI, wI = wI, Mρ = Mρ, wρ = wρ, R_Sρ = R_Sρ, R_Iρ = R_Iρ)
end


# Helper to get the tf from the impulse response
function impRes2tf(h::Vector{<:Real})
    den = zeros(length(h))
    den[1] = 1
    return tf(h, den, 1) # discrete
    # return tf(h, den) # continous
end
#turns poles that are given in polar coordinates into a complex pole
function pol2imag(M::Real, ϕ::Real)
    return Complex(M * cos(ϕ), M * sin(ϕ))
end


@recipe function f(model::BaselliModel; plotphase = false)
    w = range(0, stop = π, length = 256)
    
    layout := (4,3)
    # layout := @layout [_ G_IS R_Iρ MI
    # G_SS G_SI R_Sρ MS
    # wS wI wρ Mρ]
    
    @series begin
        mag, phase, w = bode(model.Mρ, w)
        title := "Mρ"
        subplot := 11
        (w./2π), plotphase ? vec(phase) : vec(mag)
    end
    
    @series begin
        mag, phase, w = bode(model.G_IS, w)
        title := "G_IS"
        subplot := 1
        (w./2π), plotphase ? vec(phase) : vec(mag)
    end
    
    @series begin
        mag, phase, w = bode(model.R_Iρ, w)
        title := "R_Iρ"
        subplot := 2
        (w./2π), plotphase ? vec(phase) : vec(mag)
    end
    
    @series begin
        mag, phase, w = bode(model.MI, w)
        title := "MI"
        subplot := 3
        (w./2π), plotphase ? vec(phase) : vec(mag)
    end
    
    @series begin
        mag, phase, w = bode(model.G_SS, w)
        title := "G_SS"
        subplot := 4
        xguide := "f [c/b]"
        (w./2π), plotphase ? vec(phase) : vec(mag)
    end
    
    @series begin
        mag, phase, w = bode(model.G_SI, w)
        title := "G_SI"
        subplot := 5
        xguide := "f [c/b]"
        (w./2π), plotphase ? vec(phase) : round.(vec(mag), digits = 2)
    end
    
    @series begin
        mag, phase, w = bode(model.R_Sρ, w)
        title := "R_Sρ"
        subplot := 6
        xguide := "f [c/b]"
        (w./2π), plotphase ? vec(phase) : vec(mag)
    end
    
    @series begin
        mag, phase, w = bode(model.MS, w)
        title := "MS"
        subplot := 7
        xguide := "f [c/b]"
        (w./2π), plotphase ? vec(phase) : vec(mag)
    end
    
    @series begin
        title := "wS"
        subplot := 8
        model.wS
    end
    @series begin
        title := "wI"
        subplot := 9
        model.wI
    end
    @series begin
        title := "wρ"
        subplot := 10
        model.wρ
    end
end